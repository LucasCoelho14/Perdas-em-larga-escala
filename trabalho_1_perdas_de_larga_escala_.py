# -*- coding: utf-8 -*-
"""Trabalho 1 - Perdas de Larga Escala .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EmQhtgU-WIUmazCk7Z9ofwE0sZRes2PS

## **Extração dos dados e cálculo das distâncias**
"""

import pandas as pd
import io
from geopy.distance import geodesic

def calculate_distance(row, antena_pos):
    point = (row['latitude'], row['longitude'])  # Certifique-se de usar os nomes corretos
    return geodesic(point, antena_pos).meters  # Distância em quilômetros

df = pd.read_csv('data.txt', sep='\t', header=None, skiprows=3) # Carregar o arquivo
df.columns = ['Timestamp', 'longitude', 'latitude', 'Operatorname', 'NetworkTech', 'level', 'Speed', 'Altitude', 'Filemark'] # Adicionar nomes às colunas

antenna_position = (-21.794406, -43.357198)
df['distance_to_antenna'] = df.apply(lambda row: calculate_distance(row, antenna_position), axis=1)
print(df.head())

selected_columns = df[['distance_to_antenna', 'level']] # Selecionar apenas as colunas desejadas
row = selected_columns.to_numpy() # Converter em uma matriz NumPy
print(row) # Mostrar a matriz

"""### 3) Montar tabela com distância da ERB ao celular e potência recebida."""

# Bibliotecas e formatação
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
plt.rcParams.update({
    'font.family': 'serif',
    'mathtext.fontset': 'dejavuserif',

    # Tamanhos de fonte globais
    'font.size': 12,           # Tamanho base
    'axes.titlesize': 16,      # Título do gráfico
    'axes.labelsize': 16,      # Rótulos dos eixos (xlabel, ylabel)
    'xtick.labelsize': 12,     # Ticks do eixo x
    'ytick.labelsize': 12,     # Ticks do eixo y
    'legend.fontsize': 12,     # Legenda
    'figure.titlesize': 16,    # Título da figura (se usar suptitle)
})
data = np.array(row)

data = data[data[:, 0].argsort()]
distances = data[:, 0]
powers = data[:, 1]

from tabulate import tabulate

# Preparar dados para tabulate
table_data = []
for i, (param, potencia) in enumerate(data):
    table_data.append([
        i+1,
        f"{param:.4f} m",
        f"{potencia:.1f} dBm"
    ])

headers = ["Amostra", "Distância", "Potência do Sinal"]

print("TABELA: Distância vs RSRP")
print("="*50)
print(tabulate(table_data, headers=headers, tablefmt="grid"))
print("="*50)

# Converte tabela para o latex
latex_table = """\\begin{tabular}{|c|c|c|}
\\hline
Amostra & Distância (km) & RSRP (dBm) \\\\
\\hline
"""

for i, (dist, power) in enumerate(zip(distances, powers), 1):
    latex_table += f"{i}  & {dist:.4f} & {power:.1f} \\\\\n"

latex_table += """\\hline
\\end{tabular}"""

print(latex_table)

"""### 4) Montar gráfico com Potência Recebida em dBm X log(d)."""

# Plot da Potência Recebida vs Distância
log_distances = np.log10(distances)
plt.figure(figsize=(10, 6))
plt.scatter(log_distances, powers, color='blue', s=50, alpha=0.7, label='Dados medidos')
plt.xlabel(r'$\log_{10}(d)$')
plt.ylabel('RSRP (dBm)')
plt.title('Potência Recebida em dBm X log(d)')

"""### 5) Encontrar reta que melhor se adequa aos pontos medidos e encontrar valor do índice de decaimento n."""

print("=== REGRESSÃO LINEAR ===")

# Regressão linear em escala logarítmica
log_distances = np.log10(distances)
slope, intercept, r_value, p_value, std_err = stats.linregress(log_distances, powers)

print(f"PARÂMETROS DA REGRESSÃO:")
print(f"   Inclinação (A): {slope:.4f} dB/década") # Inclinação da reta de regressão
print(f"   Intercepto (B): {intercept:.4f} dB") # Valor da ordenada y quando a abscissa é d = 1
print(f"   R-value: {r_value:.4f}") # Correlação linear, varia de -1 a 1
print(f"   P-value: {p_value:.6f}") # Probabilidade de obter uma correlação tão forte por acaso, assumindo que não há relação real. p < 0.05: Correlação estatisticamente significativa
print(f"   Std err: {std_err:.4f}") # Erro Padrão da Inclinação
print(f"   Coeficiente R²: {r_value**2:.4f}") # Coeficiente de determinação de Y por X.

n = slope / 10  # PL(d) = 10*n*log10(d) + B, n = A/10

print(f"Índice de decaimento n:")
print(f"   Parâmetro n: {n:.4f}")

# Plot da Regressão Linear

plt.figure(figsize=(10, 6))
x_fit = np.linspace(min(distances), max(distances), 100)
log_x_fit = np.log10(x_fit)
y_fit = slope * log_x_fit + intercept
plt.plot(log_x_fit, y_fit, 'r-', linewidth=2, label=f'Regressão: y = {slope:.2f}*log10(d) + {intercept:.2f}')
plt.scatter(log_distances, powers, color='blue', s=50, alpha=0.7, label='Dados medidos')
plt.xlabel(r'$\log_{10}(d)$')
plt.ylabel('RSRP (dBm)')
plt.title('Regressão Linear dos Pontos Medidos')
plt.grid(True, alpha=.5)
plt.legend()
plt.show()

"""### 6) Modelo de perda de caminho log-distância.

$\overline{PL}_\text{dB} = \overline{PL}_\text{dB}(d_0) + 10n\cdot\log_{10}\left({\frac{d}{d_0}}\right)$


$\overline{PL}_\text{dB} = -67,89 - 20,75\cdot\log_{10}\left({\frac{d(\text{m})}{36,17~\text{m}}}\right)$
"""

PL_d0 = y_fit[0]
d0 = distances[0]
PL = PL_d0 + 10*n*np.log10(distances/d0)

# Plot do modelo de perda de caminho log-distância

plt.figure(figsize=(10, 6))
x_fit = np.linspace(min(distances), max(distances), 100)
log_x_fit = np.log10(x_fit)
y_fit = slope * log_x_fit + intercept
plt.plot(log_distances, PL, 'r-', linewidth=2, label=f'PL(d): y = {slope:.2f}*log10(d/{d0:.2f}) + {PL_d0:.2f}')
plt.scatter(log_distances, powers, color='blue', s=50, alpha=0.7, label='Dados medidos')
plt.xlabel(r'$\log_{10}(d)$')
plt.ylabel('RSRP (dBm)')
plt.title('Modelo de perda de caminho log-distância')
plt.grid(True, alpha=.5)
plt.legend()
plt.show()

"""### 7) Desvio-padrão para o modelo com sombreamento a partir da nuvem de pontos medidos.



"""

# Cálculo do RMSE
y_pred = slope * log_distances + intercept
residuals = powers - y_pred
rmse = np.sqrt(np.mean(residuals**2))

print(f"CÁLCULO DO RMSE:")
print(f"   Soma dos quadrados dos resíduos: {np.sum(residuals**2):.4f}")
print(f"   Número de pontos: {len(residuals)}")
print(f"   MSE: {np.mean(residuals**2):.4f} dB²")
print(f"   RMSE: {rmse:.4f} dB")

# Variância e desvio padrão para modelo com sombreamento
variance = np.var(residuals, ddof=1)
sigma = np.std(residuals, ddof=1) # Desvio padrão da amostra. Assume-se que os dados oscilam ao redor da reta obtida com a regressão linear.

print(f"VARIÂNCIA E DESVIO PADRÃO:")
print(f"   Variância (σ²): {variance:.4f} dB²")
print(f"   Desvio padrão (σ): {sigma:.4f} dB")

"""$\sigma = \sqrt{\frac{1}{18-1} \sum_{i=1}^{18} ({PL}_\text{dBm} - \overline{PL}_\text{dBm})^2} = 4,07$

### 8)  Propor modelo log-distância com sombreamento (a) descorrelacionado e (b) correlacionado.

#### (a) Modelo log-distância com sombreamento descorrelacionado
"""

print("\n=== MODELO DESCORRELACIONADO ===")

# Função que gera o modelo log-distância com sombreamento descorrelacionado
def generate_uncorrelated_model(distances, slope, intercept, sigma, num_realizations=5):
    """Gera realizações do modelo descorrelacionado"""
    log_distances = np.log10(distances)
    realizations = [] # Lista para guardar as realizações da variável aleatória X_sigma
    rd = np.random.default_rng(12345)
    for i in range(num_realizations):
        # Gerar sombreamento aleatório descorrelacionado
        X_sigma = rd.normal(0, sigma, len(distances)) # Variável aleatória de média zero com desvio padrão sigma.
        # Aplicar modelo: PL(d) = A*log10(d) + B + X_sigma
        y_uncorr = slope * log_distances + intercept + X_sigma
        realizations.append(y_uncorr) # Cada realização é armazenada na lista realizations
    return realizations

# Gerar realizações descorrelacionadas
uncorrelated_realizations = generate_uncorrelated_model(
    distances, slope, intercept, sigma, num_realizations=5
)

# Plot comparativo
plt.figure(figsize=(12, 6))
# Dados originais e regressão
plt.plot(log_x_fit, y_fit, 'k-', linewidth=2, label='Regressão linear', zorder=4)
plt.scatter(log_distances, powers, color='black', s=60, label='Dados medidos', zorder=5)

# Realizações descorrelacionadas
colors = ['blue', 'green', 'orange', 'purple', 'brown']
for i, realization in enumerate(uncorrelated_realizations):
    plt.scatter(log_distances, realization, color=colors[i], s=30, alpha=0.7,
               label=f'Sombreamento {i+1}')
    plt.plot(log_distances, realization, color=colors[i], alpha=0.5, linewidth=1)

plt.xlabel(r'$\log_{10}(d)$')
plt.ylabel(r'$\overline{PL}_\text{dBm}$')
plt.title('Sombreamento Descorrelacionado - Comparação')
plt.grid(True, alpha=0.3)
plt.legend()
plt.show()

print(f"Cada realização adiciona ruído gaussiano N(0, {sigma:.2f}) independente por ponto")

"""#### (b) Modelo log-distância com sombreamento correlacionado"""

# Parâmetros
d_dec = 9  # m
ant_lat, ant_lon = antenna_position # Posição da antena (lat, lon)
shift = d_dec / 2  # Ajuste

# Converter coordenadas para metros relativos à antena
def latlon_to_m(lat, lon, ref_lat, ref_lon):
    # distância leste-oeste (x)
    p_east = (ref_lat, lon)
    x = geodesic((ref_lat, ref_lon), p_east).meters
    if lon < ref_lon:
        x = -x
    # distância norte-sul (y)
    p_north = (lat, ref_lon)
    y = geodesic((ref_lat, ref_lon), p_north).meters
    if lat < ref_lat:
        y = -y
    return x, y

x_arr, y_arr = [], []
for lat, lon in zip(df['latitude'], df['longitude']):
    x, y = latlon_to_m(lat, lon, ant_lat, ant_lon)
    x_arr.append(x)
    y_arr.append(y)
x_arr, y_arr = np.array(x_arr), np.array(y_arr)

# Criar grade em metros — ajustada para centralizar o primeiro ponto
margin = d_dec * 2
x_start = x_arr.min() - margin - shift
y_start = y_arr.min() - margin - shift

x_grid = np.arange(x_start, x_arr.max() + margin + d_dec - shift, d_dec)
y_grid = np.arange(y_start, y_arr.max() + margin + d_dec - shift, d_dec)
n_x, n_y = len(x_grid), len(y_grid)

# χ_i ~ N(0, σ)
rng = np.random.default_rng(12345)
Xi = rng.normal(0.0, sigma, size=(n_y, n_x))

tol = 1e-6
chiP, chiPcorr, d_list = [], [], []

for xP, yP, latP, lonP in zip(x_arr, y_arr, df['latitude'], df['longitude']):
    i = np.searchsorted(x_grid, xP) - 1
    j = np.searchsorted(y_grid, yP) - 1
    i = int(np.clip(i, 0, n_x - 2))
    j = int(np.clip(j, 0, n_y - 2))

    # Frações normalizadas
    X = (xP - x_grid[i]) / d_dec
    Y = (yP - y_grid[j]) / d_dec

    # χ nos 4 vértices (I, II, III, IV)
    chi_I   = Xi[j+1, i]     # superior esquerdo
    chi_II  = Xi[j+1, i+1]   # superior direito
    chi_III = Xi[j, i]       # inferior esquerdo
    chi_IV  = Xi[j, i+1]     # inferior direito

    # Interpolação bilinear (Eq. 7.7)
    chi_p = ((chi_I * (1 - X) + chi_II * X) * (1 - Y) +
             (chi_III * (1 - X) + chi_IV * X) * Y)

    # CORREÇÃO: χP' = 0 quando X ou Y estão nos vértices (0 ou 1)
    if (abs(X) < tol or abs(X - 1) < tol) and (abs(Y) < tol or abs(Y - 1) < tol):
        chi_p_corr = 0.0
    else:
        denom = np.sqrt((1 - 2*X + 2*X**2) * (1 - 2*Y + 2*Y**2))
        chi_p_corr = chi_p / denom if denom > tol else chi_p

    # Distância à antena (m)
    d = geodesic((latP, lonP), antenna_position).meters
    d_list.append(max(d, 1.0))

    chiP.append(chi_p)
    chiPcorr.append(chi_p_corr)

# Combinar em um array 2D: [distância, chiPcorr]
combined_array = np.column_stack((np.array(d_list), np.array(chiPcorr)))
sorted_array = combined_array[combined_array[:, 0].argsort()]

d = sorted_array[:, 0]
chiPcorr = sorted_array[:, 1]

# Modelo de perda correlacionado
PL_corr = slope * np.log10(d) + intercept + chiPcorr  # CORREÇÃO: usar log10(d) em vez de log_distances

# (a) Plot: Grade de χ_i e localizações
fig, ax = plt.subplots(figsize=(10, 5))

# Limites do gráfico definidos pelo intervalo total dos dados + margem, sempre incluindo 0
x_plot_min = min(x_grid.min(), x_arr.min(), 0) - d_dec
x_plot_max = max(x_grid.max(), x_arr.max(), 0) + d_dec
y_plot_min = min(y_grid.min(), y_arr.min(), 0) - d_dec
y_plot_max = max(y_grid.max(), y_arr.max(), 0) + d_dec

ax.set_xlim(x_plot_min, x_plot_max)
ax.set_ylim(y_plot_min, y_plot_max)

# Grade cobrindo todo o espaço do gráfico
for xi in np.arange(x_plot_min-d_dec, x_plot_max + d_dec, d_dec):
    ax.axvline(xi, color='gray', lw=0.6, ls='--', alpha=0.6)
for yj in np.arange(y_plot_min-d_dec, y_plot_max + d_dec, d_dec):
    ax.axhline(yj, color='gray', lw=0.6, ls='--', alpha=0.6)

# Localizações medidas (azuis)
ax.scatter(x_arr, y_arr, c='blue', s=50, label='Localizações medidas')

# Pontos do grid (pretos)
x_grade = np.arange(x_start - margin - d_dec, x_arr.max() + margin + d_dec , d_dec)
y_grade = np.arange(y_start - margin - d_dec, y_arr.max() + margin + d_dec , d_dec)
xx, yy = np.meshgrid(x_grade, y_grade)
ax.scatter(xx, yy, color='k', s=10, label='Pontos do grid')
# Antena
ax.scatter(0, 0, marker='*', color='gold', s=150, edgecolor='k', label='Antena (0,0)')

ax.set_xlabel("x (m)")
ax.set_ylabel("y (m)")
ax.set_aspect('equal', adjustable='box')
ax.set_title(r"Grade de $\chi_i$")

# Eixo x com menos valores para evitar sobreposição
step_xticks = max(1, len(x_grid) // 10)
ax.set_xticks(x_grid[::step_xticks])

ax.grid(True, which='both', alpha=0.3, ls='--')
ax.legend(loc='upper right')
plt.tight_layout()

# (b) Modelo correlacionado + comparação
plt.figure(figsize=(12, 6))
logd_cont = np.linspace(np.log10(d).min(), np.log10(d).max(), 100)  # CORREÇÃO: usar log10(d)
PL_noshadow = intercept + slope * logd_cont
plt.plot(logd_cont, PL_noshadow, 'b-', linewidth=2,
         label=f'Regressão linear')

# CORREÇÃO: Adicionar realização descorrelacionada se existir
if 'realization' in locals():
    plt.scatter(np.log10(d), realization, color='green', s=30, alpha=0.7,
                label=f'Sombreamento Descorrelacionado')
    plt.plot(np.log10(d), realization, color='green', alpha=0.5, linewidth=1)

plt.plot(np.log10(d), PL_corr, 'ro', markersize=6, alpha=0.8,
         label=r'Sombreamento Correlacionado')

plt.scatter(np.log10(d), powers, alpha=0.7, color='blue',
           s=50, label='Dados medidos')

plt.title('Sombreamento Correlacionado - Comparação')
plt.xlabel(r'$\log_{10}(d)$')
plt.ylabel(r'$\overline{PL}_\text{dBm}$')
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()

# -----------------------
# Resultado final
df_result = df.copy()
df_result['x_m'] = x_arr
df_result['y_m'] = y_arr
df_result['d_to_BS_m'] = d
#df_result['chiP'] = chiP
df_result['chiP_corr'] = chiPcorr
df_result['PL_corr_dB'] = PL_corr

# Verificar se χP' = 0 nos vértices
print("Verificação de χP' nos vértices do grid:")
for i, (x, y, chi_p, chi_p_corr) in enumerate(zip(x_arr, y_arr, chiP, chiPcorr)):
    # Verificar se está próximo de um vértice do grid
    x_vertex = any(abs(x - xv) < tol for xv in x_grid)
    y_vertex = any(abs(y - yv) < tol for yv in y_grid)
    if x_vertex and y_vertex:
        print(f"Ponto {i+1}: ({x:.2f}, {y:.2f}) - χP = {chi_p:.3f}, χP' = {chi_p_corr:.3f} (vértice)")

print(f"\nEstatísticas do shadowing:")
#print(f"χP:  média = {chiP.mean():.3f}, std = {chiP.std():.3f}")
print(f"χP': média = {chiPcorr.mean():.3f}, std = {chiPcorr.std():.3f}")
print(f"Número de pontos com χP' = 0: {np.sum(np.abs(chiPcorr) < tol)}")

print(df_result[['x_m','y_m','d_to_BS_m','chiP_corr','PL_corr_dB']].head())